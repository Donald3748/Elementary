>#扫雷
>首次使用EasyX版

##程序功能说明
>本程序实现了通过图形化界面实现经典小游戏—扫雷的重现，它包含了：
> 
>1.难度的选择（简单，中等，困难），大小与磊的数量均对标标准版
>2.右键点击一次实现对雷的标记，再次点击取消
>3.确保第一次点击位置一定不是雷

##各文件内容说明
>`needings.h`
 包含头文件，命名空间，常变量，类定义与函数

>`tools.cpp`
 各函数的具体定义

>`main.cpp`
 整体程序的调用

##整体思路
1. 通过二维向量board储存各个点位的值，0-8代表周围的雷的数量，9代表该位置是生成的位置
2. 相同大小的二维向量status代表各个点的状态，分别为`normal`、`cleared`、`marked`
3. 自定义两个颜色，颜色均已包含在头文件中，使用HSV，可更改
4. 变量：
   `stay_x,stay_y` 代表当前鼠标停留的==像素位置==
   `just_moved_x,just_moved_y` 代表上一个鼠标停留的==格子==
   `is_over` 代表游戏已经结束
   `is_win` 代表游戏已经胜利
   `is_first_click` 代表是鼠标的第一次合法点击（保证第一次点击位置非雷）
   `mines_num` 代表雷的总数
   `picked_num` 代表已经被标记的雷的个数


##函数作用剖析
-  `get_mode_and_initialize`
  初始化难度选择页面；设置字体大小；resize内部board和status数组的大小
- `random_form`
  随机生成内部的雷的布局；保证生成雷的位置一定不重叠；生成所有的格子数字
- `show_notice`
  弥补outtextxy无法输出int型数据的缺憾，在左上角打印当前雷数目信息
- `print_frame`
  打印出带颜色和网格线的雷区，打印剩余雷个数信息
- `control_by_mouse`
  管理每一次的鼠标事件（移动，🤛，🤜）判断游戏结束条件
- `move`
  鼠标移动事件，改变`stay_x,stay_y` 和`just_moved_x,just_moved_y`,实现当前鼠标停留块为白色，打印下方位置消息
- `get_empty_cleared`
  递归函数，寻找连续的0的位置
- `click`
  鼠标左击事件，判断点击位置合法性，是否踩雷；实现点击位置如果是0就清楚周围所有0的位置和0的周边八格（模仿标准游戏）
- `flag`
  鼠标右击事件，判断点击位置合法性，改变标记状态，改变左上角当前雷数目信息
- `justice`
  判断游戏是否结束（检测是否胜利）
- `end_manage`
  管理游戏结束之后的成败信息的打印，如果已经结束就揭露场上所有布局
- `is_to_continue`
  判断是否继续游戏
- `clear`
  清除所有依然布局（连续进行多回合游戏时进行状态清零）